---
title: 如何调用GPT API
date: 2023-12-28 18:00:00 +0800
categories: [AIGC, OpenAI]
tags: [chatgpt]
---

## 引言
GPT API通过其先进的自然语言处理能力，为人类和机器之间的交互提供了新的可能性。也就是说，gpt的出现，大大降低了AI相关工具的开发难度的同时，也给很多工具开发的机会，API的调用是开发和调试工具的基础。

## GPT API申请

目前能够获取API的方法并不多，这里会给出几种目前较为流行的获取方式。

1. OpenAI官方
    
    OpenAI官方提供API支持，而且目前主流的工具都支持官方API的调用方式。缺点是API需要翻墙，并且支付很难，不支持国内任何信用卡支付，目前（2023年12月28日）很多国内的用户，为了支付API的费用，去开通美国或者新加坡等国外的信用卡，甚至开通很多灰产会使用的虚拟信用卡和虚拟货币（比如USDT，国外很多诈骗和赌博分子洗钱用虚拟货币）。
    
    建议薅完开账号的送的几刀羊毛之后就可以不用了，这里也不提供虚拟信用卡的开卡经验，如果必须要使用官方API，用其他的咳嗽，最好去开新加坡的ICBC信用卡，至少属于正规渠道，网上有很多教程，这里不再赘述。

2. 微软OpenAI
    
    实际上就是business版本的OpenAI官方API，优点是相对支付方便，国内信用卡支付即可，而且提供的API不需要翻墙就可以使用。难点是需要公司邮箱来申请，如果有公司邮箱，现在直接申请，一般24小时内都会通过，而且通过之后，可以获取200刀的首月免费额度，同时API是可以在国内直接使用不需要翻墙。并且目前gpt-4也同时得到支持了，只需要更换地区就可以直接使用，月底统一结账。申请方法网上有很多现成的，这里也不再赘述。
    ![主题](/assets/image/20231228210358.png)

    价格上基本上和OpenAI官方一致，切记一点，不要使用微软的微调模型，这是价格上最大的一点不同，如下图所示：
    ![主题](/assets/image/20231228205010.png)
    注意圈红的位置，这里就是微软和官方最大的不同，微调一次模型需要根据时间收费上百刀，并且微调模型运行时也会根据时间收费，而OpenAI官方微调是完全免费的。
    
    这里建议如果必须要使用的微调模型的同学，务必使用官方提供的微调模型。目前使用微调模型主要是微调GPT-3.5模型，用以达到GPT-4.0的能力，由于目前已经推出了更便宜的GPT-4.0 turbo模型，完全可以使用提前喂上下文的GPT-4.0 turbo模型替代微调GPT-3.5模型。

3. 第三方 or 其他
    
    由于所有第三方最终都会指向收费的OpenAI官方或者微软OpenAI，所以长期价格上不可能低于OpenAI的价格，除非一些灰产，比如刷初始号送的，整体价格上会低于官方，但是使用上会非常麻烦，要经常更换API key。

我自己目前使用的方案是ChatGPT Plus + 微软OpenAI API，ChatGPT Plus使用美区Appstore+美区PayPal+国内信用卡绕开ChatGPT Plus的国内信用卡限制，微软OpenAI使用公司邮箱开通，支付上直接使用国内信用卡。

一方面ChatGPT Plus如果重度使用是非常划算得，这个如果之前有调用过API就知道API价格看起来便宜实际上是比较昂贵的。一方面开发工具和调试等，依赖API和OpenAI提供的调试平台，这个调试平台非常好用，下面会有介绍。

## GPT API使用

这里使用上以微软的OpenAI介绍为主，其他都大同小异。

1. 创建 Azure OpenAI

    因为模型和地区限制有关，可能之前创建的时候选择的地区不对，可能导致有些模型是无法在该地区使用的，解决办法很简单，重新创建一个地区支持的就好。
    比如美东不直接支持GPT-4.0模型，但是瑞典中部就直接支持。
    ![主题](/assets/image/20231228211604.png)

    创建Azure OpenAI比较简单，如下图所示，先进入OpenAI服务，再点创建，填好其他信息之后，地区选瑞典中部并创建即可
    ![主题](/assets/image/20231228211830.png)
    ![主题](/assets/image/20231228212033.png)
    ![主题](/assets/image/20231228212114.png)

2. 部署模型

3. 调试模型

4. 代码调用

